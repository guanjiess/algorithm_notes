##2024.02.26~03.03

02.29

- 代码随想录1、2、3、4
- 主要是数组相关。
- 需要看看**算法笔记二分查找**的扩展部分。
- 数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。

03.01

- 代码随想录5，滑动窗口，套路性比较明显，思想比较有趣。

- 代码随想录6，螺旋矩阵，分情况比较费脑子，**内存、数组边界容易出问题**，动辄导致几个小时的debug时间，需要各位注意。Carl的题解比较优雅，**行就是行、列就是列**，整一些莫名奇妙的递推式容易把自己绕进去，添加不必要的思维负担。

  ```c++
  int i = start_x;
  int j = start_y;
  
  for(j = start_y; j < n - offset; j ++){
      ans[start_x][j] = count++;
  }
  for(i = start_x; i < n - offset; i ++){
      ans[i][j] = count++;
  }
  for(; j > start_y; j --){
      ans[i][j] = count++;
  }
  for(; i > start_x; i --){
      ans[i][j] = count++;
  }
  //注意，是个左闭右开的区间
  ```

  - 需要**对各个区间有明确、统一的定义**，比如统一规定取左开右闭。

##2024.03.04~03.10

03.04

- 代码随想录。链表相关，3-8
- 需要注意反转链表、两两交换链表这两道题里面的一些小tricks，尤其是while循环内部的判断条件。
- 注意不要访问空指针

03.05

- 代码随想录，哈希相关。
- **哈希的优点在于查询速度快**，可以根据元素的映射下标快速索引数据。C++标准库中的 **unordered_set, unordered_map的底层实现都是哈希**，有着最高的查询、删除效率。其内部的数据是无序的。
- 用空间换时间的策略
- 想要查询元素是否曾经出现过，用哈希，(set)
- 想要知道元素和元素的附带属性（如下标），用map

![1709608670725](E:\master2\coding_notes\DSA\刷题记录2-随想录.assets\1709608670725.png)

- **leetcode15, leetcode18。值得多看两遍。**

> a的去重：
>
> 这段注释的意思是，这是一种正确的去重方法，用于避免重复考虑相同的元素。在这段注释中，作者提到了一种正确的去重方法，即通过比较当前元素`nums[i]`与前一个元素`nums[i - 1]`是否相等来进行去重操作。如果相等，则直接跳过当前元素。
>
> 这种正确的去重方法的作用是确保不重复考虑相同的元素，避免重复计算相同的三元组。通过在循环遍历`nums`时进行这样的去重操作，可以保证每个元素只被考虑一次，避免重复的组合，从而得到正确且不重复的三元组解。这种方法是有效的，可以提高算法的效率并得到正确的结果。
>
> 
>
> 对于b、c的去重逻辑的设置理由如下：
>
> 1. 避免重复计算相同的三元组：在找到一个满足条件的三元组(a, b, c)后，需要对b和c进行去重，以避免重复计算相同的三元组。如果不对b和c进行去重，可能会出现重复的组合，导致得到重复的三元组解。
>
> 2. 确保不重复考虑相同的元素：在找到一个满足条件的三元组后，需要将`left`和`right`指针分别向内移动，跳过与当前元素相同的元素。这样可以确保在下一次迭代时，不会再次考虑与当前三元组中相同的元素组合。
>
> 通过对b和c的去重逻辑设置，可以确保算法不会重复计算相同的三元组，避免重复的组合，并得到正确的且不重复的三元组解。这样可以提高算法的效率并确保得到正确的结果。
>
> **这种方式能够保证遍历得到所有的正确结果的原因在于以下几点：**
>
> 1. 排序数组：在算法开始时，对输入的数组进行排序，可以确保相同的元素相邻排列在一起，方便进行去重操作。
>
> 2. 去重逻辑：在找到一个满足条件的三元组(a, b, c)后，对b和c进行去重操作，确保不会重复计算相同的三元组。通过在移动`left`和`right`指针时跳过与当前元素相同的元素，可以避免重复的组合。
>
> 3. 双指针移动：通过双指针的移动，使得在每次迭代中都考虑不同的元素组合，遍历所有可能的情况。同时，通过合理的去重逻辑，确保不会重复考虑相同的元素。
>
> 综合以上几点，这种方式能够保证遍历得到所有的正确结果，即找到所有满足条件的三元组解，并且保证这些解都是不重复的。通过合理的排序、去重逻辑和双指针移动，算法能够有效地遍历所有可能的情况，得到正确的且不重复的三元组解。

03.06

- 字符串

03.07

- KMP算法，每一个概念、每一个步骤的原理都要弄明白，最好整理出来一些笔记，自己输出一遍。
- 算法笔记+AcWing，都不错。**kmp算法模板多敲几遍。**
- next数组可能会报错，用ne会万无一失。

03.08

- 栈与队列和STL的关系
- **SGI STL是开源软件，源码可读性甚高** 
- 栈：先进后出（first in last out）的数据结构，底层实现可以是 vector，deque，list。主要以数组和链表作为底层实现。
- SGI STL默认以deque为底层结构实现栈。

- **逆波兰表达式**，中缀表达式（就是我们正常用的结构）。
- 边界条件很复杂的算法、数据结构，最好记住一些模板。

-----

- 大顶堆（堆头是最大元素），小顶堆（堆头是最小元素）------>堆就是完全二叉树，树中的每个节点的值都不小于或不大于其左右孩子节点的值。
- 优先级队列，**priority_queue**。

-----

- 二叉树：有左右子节点
- 满二叉树：一棵树只有度为0或度为2的节点（就是那种很饱满的树）
- 完全二叉树：每一层都铺满了，只有最底层没有铺满，但是最底层的左侧也是铺满的。
- 二叉搜索树：一个有序树，根节点的值大于等于左子树上所有节点的值；根节点上的值小于等于所有右子树节点上的值。同时，它的所有子树本身也是二叉搜索树。
- 平衡二叉搜索树：AVL树，它的左右子树高度差不超过1，且左右子树都是平衡二叉树。
- C++中的map\set\multimap\multiset底层实现都是平衡二叉搜索树。

----

- **递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中**，然后递归返回的时候，从栈顶弹出上一次递归的各项参数。
- 用栈实现统一的迭代二叉树遍历：见代码随想录，二叉树4，非常精妙，没事多看几遍、多敲几遍。



---

- ==03.09==

- 强度拉满，收获很大的一天。
- 上午美团笔试，2小时5道算法写了3道，还是抄的GPT的答案，大概率过不了笔试。
- 下午PAT甲级考试，三小时4道题，勉强写出来两道。
- 晚上360笔试，选择题就是408基础内容，编程题难度也不小。

**收获**

- **STL模板的用法**，链表、二叉树、图等等数据结构的增删改查，常见的排序、遍历算法，都要在理解的基础上**背下来常用模板**，可以极大地提高效率，避免很多边界条件debug问题，也方便我们专注在问题核心上。
- C/C++语言的很多特性不熟悉，包括继承多态、引用等等，需要写几行代码验证一下。
- 进程、线程、并发、内存管理相关的概念很重要，需要结合实践去理解一下。
- 大厂笔试也可以用自己IDE？怎么用？PAT考试可以用自己的IDE？
- 怎么高效地利用print来debug算法题？----->我的想法是随手写一些打印数组、图结构的小工具函数，固定下来形成肌肉记忆之后，可能花个一两分钟就能写出来。
- 再进一步，C++、linux上面的调试工具











