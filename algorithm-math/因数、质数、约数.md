## 常用不等关系

$$
\left\lceil \frac{b}{a} \right\rceil = \left\lfloor \frac{a+b-1}{b} \right\rfloor = \left\lfloor \frac{b-1}{a} \right\rfloor + 1
$$

$$
ab  \ge  c~~~~ \Longleftrightarrow a>\left\lceil \frac{c}{b} \right\rceil
$$



## 约数

辗转相除法

### 求因数

```C++
vector<int> get_divisors(int x){
    vector<int> ans;
    for(int i = 1; i <= x / i; i++){
        if(x % i == 0){
            ans.push_back(i);
            if(i != x/i){
                ans.push_back(x/i);
            }
        }
    }
    return ans;
}
```







## 质数

1、定义：大于1的自然数，且除了1和它本身外，不能被其他自然数整除的数。

###**质数的判定**

- 试除法，时间复杂度   O(sqrt(n))
- 为什么只需要选到 sqrt(n) ？ 

```C++
bool is_prime(int n){
    if (n < 2) return false;
    // 用i < n / i的形式没有溢出风险，i*i可能会导致溢出
    for(int i = 2; i < n / i; i++)
        if(n % i == 0)
            return false;
    return true;
}
```

### 筛质数

https://www.acwing.com/video/293/



###质因数

- 一个数中的质数因子，即能整除该数且是质数的因子。 对于整数 12，它的质因数为 2 和 3，因为 12 可以被分解为 2 * 2 * 3，其中 2 和 3 都是质数。因此，12 的质因数为 2 和 3。 

- 试除法，时间复杂度，介于log(n)和O(sqrt(n))之间

- 为什么在sqrt(n)之间，因为一个正整数的因子是成对出现的。如果一个大于sqrt(n)的数字可被整除，那么一定有一个小于sqrt(n)的数字也可以被整除，二者只需要知道其中一个就可以了。
  $$
  n=i*\frac{n}{i}  \rightarrow  i*i\le n
  $$
  

```C++
void divide(int x){
    // 从2开始，从小到大地筛选x的因子
    for(int i = 2; i <= x / i; i++){
        // 表明i是x的因数
        if(x % i == 0){
            int s = 0;
            while(x % i ==  0){
                x /= i;
                s ++;
            }
            cout << i << " " << s << endl;
        }
        if(x > 1) cout <<" " << x << 1 << endl;
    }
}
```

- **为什么筛选出的i一定是质数？**
  - 假设要求得x的质因数。
  - 这个方法的思想是，从2开始逐步筛干净所有因子。以2为例，如果**x**可以被2整除，那么把x包含的 2除干净，以48为例，其可以被2整除，那么后续筛出来48中所有的48  -> 24 -> 24 -> 12 -> 6 -> 3。
  -  筛完2，继续筛3、4、5、6等等。对于4而言，如果x之前能被4整除，那么此时它已经被2除了两次，因此4这个数字已经被消去了。对于后续的4、6、8、9、10这些非质数而言，因为他们本身就是和数（由其他更小的质数因数相乘得到），因此，这些数字在此前的步骤已经被处理过了，所以**当我们处理i时，x中已经不包含2到i-1的因子。**
  - 如果n能整除i`（x % i == 0）`，而i能被2到i-1的数字整除，那么x一定能被2到i-1的数字整除，即**x包含了2到i-1的质因子，矛盾。**所以i一定是个质数。



若输入60，则有如下的计算过程

> 1. **开始**：x = 60
>
> 2. 第一次循环
>
>    ：i = 2
>
>    - 判断 `60 % 2 == 0`，成立，说明 2 是 60 的因数。
>    - 进入 while 循环，每次 x 除以 2，s 加 1。
>      - 第一次：x = 60 / 2 = 30, s = 1
>      - 第二次：x = 30 / 2 = 15, s = 2
>    - 输出：2 2（因数 2 出现了两次）
>
> 3. 第二次循环
>
>    ：i = 3
>
>    - 判断 `15 % 3 == 0`，成立，说明 3 是 15 的因数。
>    - 进入 while 循环，每次 x 除以 3，s 加 1。
>      - 第一次：x = 15 / 3 = 5, s = 1
>    - 输出：3 1（因数 3 出现了一次）
>
> 4. 之后的循环
>
>    ：i = 4, 5, 6, ... 直到 x/i（i=5时，x/i=1）
>
>    - i = 4 时，`5 % 4 != 0`，不输出。
>
>    - i = 5 时，
>
>      ```
>      5 % 5 == 0
>      ```
>
>      ，成立，说明 5 是 5 的因数。
>
>      - 进入 while 循环，每次 x 除以 5，s 加 1。
>        - 第一次：x = 5 / 5 = 1, s = 1
>      - 输出：5 1（因数 5 出现了一次）
>
> 5. **循环结束**：因为 x 最终为 1，所以没有更多输出。

最终输出

```shell
2 2
3 1
5 1
```













==练习题==

1. 计算质数：https://leetcode.cn/problems/count-primes/solutions/
2. 范围内最接近的两个质数：https://leetcode.cn/problems/closest-prime-numbers-in-range/
3. 数组乘积中不同质因数数目：https://leetcode.cn/problems/distinct-prime-factors-of-product-of-array/
4. https://leetcode.cn/problems/smallest-value-after-replacing-with-sum-of-prime-factors/



## 公因数







## 进制转换

==任意进制转十进制==





==十进制转任意进制==

```C++
// 【分析】
// 【十进制 转 负二进制】
//  c++ ：
//      除法向零取整
//      余数与被除数符号相同
//      e.g:    19  = (-9) * (-2) +   1       （10111）
//             -19  =   9  * (-2) + (-1)     （111101）
//
//  权重： 10       9       8       7       6       5       4       3       2       1       0
//        1024    -512    256     -128     64     -32      16      -8      4       -2       1
//
//  由于不同语言 针对负数的除法 有当无法整除时向上和向下取整的区别，（不同语言对于正数的除法都是向下取整）
//  因此需分析 进制表示 及 除法、取余运算 的本质
//
// 【十进制转x进制】：--------------------------------------------------------------------------------
//  本质：
//      n = a * (x)^5 + b * (x)^4 + c * (x)^3 + d * (x)^2 + e * (x)^1 + f * (x)^0
//      求 n 的 x 进制表示，本质上就是得到这里的系数 abcdef
//  对于一个数字 n 的 x 进制的表达式 abcdef 来说，更本质的x进制求法应该为：
//      1.  得到最低位的值f；
//          a.  对于二/负二进制来说，判断奇偶性即可判断f是1还是0  （除了最低位以外，其余位的权重都是偶数）
//          b.  对于其它进制来说，
//                  i.  若x为正数，则 f = n % x；
//                  ii. 但若x为负数，则这里还是需要针对不同语言的除法特性去分析，可能需要在 n % x 的基础上再进行一些运算操作得到 f
//      2.  先让 n -= f， 再让 n /= x ：
//          实际上是 先将n的最低位抹为0，之后再向右移一位， 最后 n = abcde（x进制表示）
//          （n -= f 是为了使得之后的 n /= x 是整除，避开不同语言在无法整除时存在向上向下取整的区别）
//  （由于该方法在进行 /= 运算时已经保证了是整除，因此对于任何语言都适用）
//---------------------------------------------------------------------------

class Solution
{
public:
    string baseNeg2(int n)
    {
        if (n == 0)
            return "0";

        string ans;
        while (n != 0)
        {
            // 获取当前最低位f
            if (n % -2 == 0) // 当前n为偶数，当前n的最低位为0，后续直接抹去这个最低位，除以-2即可
                ans += "0";
            else // 当前n为奇数，当前n的最低位f为1 （tips：虽然 n % -2 可能为1或-1，但不影响，都是最低位f=1）
            {
                n -= 1; // 将最低位的值抹去后，使得n变为偶数，在进行除负二操作时是整除
                ans += "1";
            }

            // 将n的负二进制表达式向右移一位
            n /= -2;
        }
        reverse(ans.begin(), ans.end()); // 除法和取余运算得到的是从低位到高位的结果，故最后要翻转
        return ans;
    }
};

作者：Yvette
链接：https://leetcode.cn/problems/convert-to-base-2/solutions/2211859/jin-zhi-biao-da-shi-de-ben-zhi-bu-tong-y-1x4a/。
```



## 高精度







## 幂运算

- 快速幂：https://leetcode.cn/problems/powx-n/
- 双模幂运算：https://leetcode.cn/problems/double-modular-exponentiation/