拓扑排序：将有向图按照前后依赖关系输出。

kahn算法

- 入度：一个点被多少个节点指着





1. 图中最长的环 https://leetcode.cn/problems/longest-cycle-in-a-graph/description/

2. 微服务群组 https://codefun2000.com/p/P1832

   > L：环的节点数量
   >
   > V：能连接到环的节点数
   >
   > H：H = L - V

   对图的东西不是很熟悉，原来的思路是直接对图做DFS，先找到并且保存所有的环、再计算内聚值，然后再排序输出计算结果。是一种比较暴力的做法，而且最后也没得到比较好的结果。后来复盘看到别人有用并查集写的、有用拓扑排序写的，我主要参考了拓扑排序的写法。

   > DFS暴力搜索：
   >
   > 1. 找到所有的环，并保存
   > 2. 计算每个环的内聚值 H = L - V，并排序
   > 3. 输出内聚值L最大的群组（相等情况下，按照最大值顺序输出），起始编号为服务器群组的编号最小的数。
   >
   > 拓扑排序：
   >
   > 1. 题目里，每一个节点最多指向一个节点。可以用拓扑排序，通过计算各节点的出入度来判断环的存在。
   > 2. 计算图中所有节点的入度，把入度为0的点加入队列
   > 3. 利用这些节点不断扩散，做BFS，最终如果有环的话，这些节点的入度一定为1。
   > 4. 找到所有的环以后，再次遍历，统计环长、保存环中最大数据、保存环的数据。
   > 5. 然后做排序。

