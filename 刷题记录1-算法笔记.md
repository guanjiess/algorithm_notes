《算法笔记》不错，我决定把算法笔记书上的例题写完，相信自己的编程能力能提升很多

- 广度优先，把每个知识点多看几遍
- 10分钟没思路就看别人题解
- 30分钟debug调不出来就抄

##2023.12.11~17

---------

一、数组

1.二分查找

- 知识点：注意数组区间的选定。左右均选择闭区间，则需要判断middle值。

2.移除元素

- 知识点：双指针。==精妙==



2023.12.16

C++标准库函数：sort()，默认从小到大进行排序。以及cmp(a, b)函数的语义是，如果a大于b，那么把a放在b前面。



##2023.12.18~24

2023.12.18

4.1的 PAT A1025写的时候稍微卡住了，中途的东西，输入数据的时候因为数组的下标值卡bug了。**犯了一个大忌**，总是想着写完一坨代码再去看整体的效果，正确的方法应该是实现一个小功能之后立刻进行相关的测试。



2023.12.19

基础的哈希。



2023.12.20

简单的递归

**边界条件输入的**bug，导致程序出现segmentation fault。

```C
int factorial(int n)
{
    if (n == 1)
        return 1;
    else 
        return n * factorial(n - 1);
}
```

修复

```C
int factorial(int n)
{
    if (n == 0)
        return 1;
    else 
        return n * factorial(n - 1);
}
```

==典例==

p115的全排序例子，我分别**踩了边界条件和子问题分解的坑**。递归有两个必要组成部分

- 边界条件  base case
- 递归式，也就是对子问题的拆解处理。
- 产出代码150行



2023.12.21

贪心。题目难度不大，主要的思想就是为了达成全局的最优，所以每一步的操作都要达成当前的最优解。

学到几个有用的技能

- 产出代码150行左右。
- 给VSCode自定义了快捷键，ctrl k 可以实现从终端到代码编辑区的切换。这种思想可以扩展到生活的方方面面。
- 算法题的测试用例可以自己手写到一个文件里，然后通过管道传送到自己写的代码文件。
- 我已经有了进行自动化测试的想法，是个进步

```bash
g++ -g greedy_section.cpp -o c && cat test.txt | ./c
```

- ==汉诺塔的递归、非递归实现==：https://www.bilibili.com/video/BV1Zh411y7XB，代码见jyy课程示例。主要思想，任意n片从a挪到c的操作，都可以认为是两片碟子进行操作，整体操作即分为三步：首先把上面小片的挪到中间，再把底面挪到右侧目的地，再把中间的小片挪到右边。这就是抽象出来的递归式，得多看。
- ==调试理论==



2023.12.22

**基础的二分法**，需要注意的点有

- 区间选择。
- 二分选择的条件问题。基本就是在一个while循环里对 mid  left right不断地做修改 
- 产出有效代码150行左右

**基础的two pointers**

- 单调矩阵的融合
- 归并排序的思路：以2路归并排序为例，将数组分为两组单独排序，随后再将两组有序序列合并为一个有序序列。
- **归并排序略微有点绕**，需要多看几遍
- 有效代码100行左右



## 2023.12.25~31



2023.12.25

- 归并排序，调试通过了递归、非递归两种形式归并排序。
- 快速排序，理解了快速排序的思想，并且调试通过
- 产出有效代码150行左右

2023.12.26

- 主要是一些基本的数学操作，数字翻转、公约数、公倍数、分数操作等，每一个都手动实现
- 产出有效代码260行左右

2023.12.27

- 质数、质因子分解相关操作，每一步都是自己实现，且经过了测试
- 产出有效代码240行左右

2023.12.28

- 大整数的加减乘除、打印操作
- 代码120行

2023.12.29

- 手写了大整数的加减、以及测试用例
- 代码100行



##2024.01.01~07

2024.01.01

- 学习基本STL容器的用法
- vector，可理解为可变长数组
- set，一个内部**自动有序且不含重复因素**的容器
- string，字符串
- map，一种键值对映射。  STL标准库中的 set 和 map**都用红黑树**实现。
- 代码100行左右

==数据结构专题==

01.02

- 栈(FILO，先进后出)
- 队列，queue，先进先出（CS61B用java实现过deque，双端队列）
-  中序转后序表达式（波兰表达式）的例子：https://zhuanlan.zhihu.com/p/570882793，后缀表达式：  [左操作数  右操作数  运算符]
- 代码200行左右，实现了一个非负整数的计算器。

01.03

- 链表的增删改查、malloc ---free   new---delete的使用
- 静态链表，可以用哈希实现
- 代码150行

01.04

- DFS，有点迷糊
- 代码100行

01.05

- 搞明白了DFS和BFS，做了相关笔记
- BFS思想大致明白了，例题代码也基本写出来了，但是有bug，，，不想再去改了
- 学到一些增量数组的小tricks
- 代码100行

01.06

- 调试通过了BFS代码，用了大概40分钟。
- 一般BFS的实现思路：一般用队列实现，从根节点开始逐级迭代，每一轮迭代时：首先取出队列的头节点--->对头节点的邻接节点分别进行匹配，如果满足条件，则记录节点所在层级并入队--->对同层其他节点的邻接点进行匹配--->循环，直到得到最终结果。

01.07

- 力扣周赛，100行代码左右
- 第一题ac
- 第二题通过  726/739个测试用例，一些边界条件问题没有考虑，是一个棋盘类问题



## 2024.01.08~14

**01.08~01.09** 

忙开题，无

**01.10**

- 二叉树的增删改查、前序、后序、中序遍历
- 代码160行左右

01.11

- 树的BFS和DFS
- 代码100行左右

01.12

- 树的DFS实现，理解后写了一遍，直接AC
- BST的增删改查
- 代码280行左右

01.13

- AVL，平衡二叉树的实现，没有具体验证
- 代码120行左右



##2024.01.15~21

01.15

- 调试了AVL树的左旋、右旋代码，插入代码还没完全掌握
- 写一个数据结构之前，==可以写一些方便调试用的小函数==，比如打印出来某个树的结构。
- 并查集的代码基本弄明白了
- 基本实现了堆的代码，比AVL树简单一些
- 代码220行左右

01.16

- 调试通过了heap的插入和创建
- 开始图的数据结构
- C++标准输入流cin遇到空格后会自动中止输入
- 代码200行左右

01.17

- return a++的具体含义是，先返回值，再加一
- 理解、实现了p354的DFS图遍历例题，这道题目比较综合，很有价值。
- 代码200行左右

01.18

- 实现了BFS的代码，==图遍历的DFS\BFS例题都很不错！==

- 实现了Dijkstra算法
- 代码150左右

01.19

- 完成了Dijkstra算法的扩展习题。DFS部分不是很明白，感觉这种递归太灵活了。。不好弄。
- 代码220行



## 2024.01.22~28

01.22-25，啥都没写

01.26

- 实现了bellman ford 算法，主要是抄了之后调试理解。
- 抄了抄SPFA算法，shortest path faster algorithm，有了BF的基础后不难理解，但是没有具体使用的场景。
- 代码180行
- 问题：Bellman ford 和SPFA算法的负权适用场景是什么？

01.27

- 实现了Floyd算法和Prim算法，简单看了看后面的kruskal算法
- 代码140行

##2024.01.29-02.04

01.29

- 实现了kruskal算法

- 记一个小bug：如果C++变量值没有进行初始化，那么它会包含一个随机值，可能会带来调试上的困难。

  >  When variables are not properly initialized in C++, their initial value is undefined. This means that the variable could contain any value, including garbage data from the memory location where it is stored. Using uninitialized variables can lead to unpredictable behavior in your program, making it difficult to debug and maintain. It's a good practice to always initialize variables before using them to ensure predictable and reliable behavior in your C++ programs. 

- 代码100行

01.30

- 动态规划开了个头
- 动态规划难的是明确两个因素：同构子问题的拆解和最优子结构，同构子问题可以理解为递归中，除了参数其余格式都一样的子问题；最优子结构是说，目标最优解可以拆分成若干个子问题最优解的和。
- 代码130行

## 2024.02.20-02.25

02.20

- 复习了基本的动态规划



##2024.02.26~03.03

- 代码随想录1、2、3、4
- 需要看看**算法笔记二分查找**的扩展部分。




























































##关于调试

简洁的代码不一定是高效的代码

- 如果可以方便后期进行调试，多写几行代码是很划算的。很多时候省的几个变量带来的bug，就可能导致多出来几个小时的调试工作量。
- 在用gdb调试时，通过给程序加上合适的断点、然后自动输出合适的信息，可以节约不少脑力活动。
- 把每个功能模块化地写出来，方便快速定位bug

## 代码统计

- [master 0e81f69] updated 2024.01.10, 32 files changed, 1039 insertions(+)
- [master 6cd2bbf] updated 0115, 9 files changed, 645 insertions(+)
- [master 719605b] updated 24.0117, 14 files changed, 669 insertions(+), 1 deletion(-)
- master 858817e] updated 01.23, 8 files changed, 388 insertions(+), 19 deletions(-)
- updated 0129, 10 files changed, 331 insertions(+), 1 deletion(-)

## 感受

- 数据结构的具体实现是一回事，但是放在问题背景下怎么去用就是另外一回事了。对我来说，把这些东西融会贯通需要大量的实践总结。



















